## Хеш-таблица

Реализуйте структуру данных типа “множество строк” на основе динамической хеш-таблицы с открытой адресацией. Хранимые строки непустые и состоят из строчных латинских букв.
Хеш-функция строки должна быть реализована с помощью вычисления значения многочлена методом Горнера. Начальный размер таблицы должен быть равным 8-ми. Перехеширование выполняйте при добавлении элементов в случае, когда коэффициент заполнения таблицы достигает 3/4.
Структура данных должна поддерживать операции добавления строки в множество, удаления строки из множества и проверки принадлежности данной строки множеству.

Вариант 1. Для разрешения коллизий используйте квадратичное пробирование.
i-ая проба g(k, i)=g(k, i-1) + i (mod m). m - степень двойки.
Вариант 2. Для разрешения коллизий используйте двойное хеширование.

**Формат ввода**
Каждая строка входных данных задает одну операцию над множеством. Запись операции состоит из типа операции и следующей за ним через пробел строки, над которой проводится операция. Тип операции – один из трех символов: + означает добавление данной строки в множество; - означает удаление строки из множества; ? означает проверку принадлежности данной строки множеству. При добавлении элемента в множество НЕ ГАРАНТИРУЕТСЯ, что он отсутствует в этом множестве. При удалении элемента из множества НЕ ГАРАНТИРУЕТСЯ, что он присутствует в этом множестве. 

**Формат вывода**

Программа должна вывести для каждой операции одну из двух строк OK или FAIL.

Для операции '?': OK, если элемент присутствует во множестве. FAIL иначе.

Для операции '+': FAIL, если добавляемый элемент уже присутствует во множестве и потому не может быть добавлен. OK иначе.

Для операции '-': OK, если элемент присутствовал во множестве и успешно удален. FAIL иначе.

**Пример**

| Ввод    | Вывод | 
|---------|-------|
| + hello | OK    |
| + bye   | OK    |
| ? bye   | OK    |
| + bye   | FAIL  |
| - bye   | OK    |
| ? bye   | FAIL  |
| ? hello | OK    |

## Обход дерева в порядке post-order

Дано число N ≤ 104 и последовательность целых чисел из [-231..231] длиной N. Требуется построить бинарное дерево, заданное наивным порядком вставки. Т.е., при добавлении очередного числа K в дерево с корнем root, если root→Key ≤ K, то узел K добавляется в правое поддерево root; иначе в левое поддерево root. Выведите элементы в порядке post-order (снизу вверх).

Рекурсия запрещена.

**Пример 1**

| Ввод | Вывод                |
|------|----------------------|
| 10   | 1 4 3 6 5 2 9 8 10 7 |
| 7    |                      |
| 2    |                      |
| 10   |                      |
| 8    |                      |
| 5    |                      |
| 3    |                      |
| 6    |                      |
| 4    |                      |
| 1    |                      |
| 9    |                      |

**Пример 2**

| Ввод | Вывод                |
|------|----------------------|
| 10   | 1 3 5 4 6 2 8 9 10 7 |
| 7    |                      |
| 10   |                      |
| 2    |                      |
| 6    |                      |
| 1    |                      |
| 9    |                      |
| 4    |                      |
| 5    |                      |
| 8    |                      |

**Пример 3**

| Ввод | Вывод                |
|------|----------------------|
| 10   | 1 2 3 7 8 6 5 10 9 4 |
| 4    |                      |
| 3    |                      |
| 9    |                      |
| 5    |                      |
| 6    |                      |
| 8    |                      |
| 7    |                      |
| 2    |                      |
| 10   |                      |
| 1    |                      |

## B-дерево

Постройте B-дерево минимального порядка t и выведите его по слоям.
В качестве ключа используются числа, лежащие в диапазоне [0..232-1]

**Требования:**

  - B-дерево должно быть реализовано в виде шаблонного класса.
  - Решение должно поддерживать передачу функции сравнения снаружи.

**Формат ввода**

Сначала вводится минимальный порядок дерева t.
Затем вводятся элементы дерева. 

**Формат вывода**

Программа должна вывести B-дерево по слоям.
Каждый слой на новой строке, элементы должны выводится в том порядке, в котором они лежат в узлах. 

**Пример 1**

| Ввод                | Вывод                |
|---------------------|----------------------|
| 2                   | 3                    | 
| 0 1 2 3 4 5 6 7 8 9 | 1 5 7                |
|                     | 0 2 4 6 8 9          | 


**Пример 2**

| Ввод                | Вывод                |
|---------------------|----------------------|
| 4                   | 3                    | 
| 0 1 2 3 4 5 6 7 8 9 | 0 1 2 4 5 6 7 8 9    |

## Порядковые статистики

Дано число N и N строк. Каждая строка содержащит команду добавления или удаления натуральных чисел, а также запрос на получение k-ой порядковой статистики. Команда добавления числа A задается положительным числом A, команда удаления числа A задается отрицательным числом “-A”. Запрос на получение k-ой порядковой статистики задается числом k. Требуемая скорость выполнения запроса - O(log n). 

**Пример 1**

| Ввод                | Вывод                |
|---------------------|----------------------|
| 3                   | 1 1 2                | 
| 1 0                 |                      |
| 2 0                 |                      |
| -1 0                |                      |


**Пример 2**

| Ввод                | Вывод                |
|---------------------|----------------------|
| 5                   | 40                   | 
| 40 0                | 40                   |
| 10 1                | 10                   |
| 4 1                 | 4                    |
| -10 0               | 50                   |
| 50 2                |                      |


## Алгоритм сжатия данных Хаффмана

Напишите две функции для создания архива из одного файла и извлечения файла из архива.

Метод архивирует данные из потока original

```cpp
void Encode(IInputStream& original, IOutputStream& compressed);
```

Метод восстанавливает оригинальные данные

```cpp
void Decode(IInputStream& compressed, IOutputStream& original);
```

где:

```cpp
typedef char byte;

interface IInputStream {
// Возвращает false, если поток закончился
virtual bool Read(byte& value) = 0;
};

interface IOutputStream {
virtual void Write(byte value) = 0;
};
```
В архиве сохраняйте дерево Хаффмана и код Хаффмана от исходных данных. Дерево Хаффмана требуется хранить эффективно - не более 10 бит на каждый 8-битный символ.

В контест необходимо отправить .cpp файл содержащий функции Encode, Decode, а также включающий файл Huffman.h. Тестирующая программа выводит размер сжатого файла в процентах от исходного.

Пример минимального решения:

```cpp
#include "Huffman.h"

static void copyStream(IInputStream&input, IOutputStream& output) {
byte value;
while(input.Read(value)) { output.Write(value); }
}

void Encode(IInputStream& original, IOutputStream& compressed) {
copyStream(original, compressed);
}

void Decode(IInputStream& compressed, IOutputStream& original) {
copyStream(compressed, original);
}
```
