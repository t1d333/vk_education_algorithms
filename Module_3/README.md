## Представление графа

Дан базовый интерфейс для представления ориентированного графа:

```cpp
struct IGraph {
  virtual ~IGraph() {}
	
  // Добавление ребра от from к to.
  virtual void AddEdge(int from, int to) = 0;

	virtual int VerticesCount() const  = 0;

  virtual std::vector<int> GetNextVertices(int vertex) const = 0;
  virtual std::vector<int> GetPrevVertices(int vertex) const = 0;
};
```

Необходимо написать несколько реализаций интерфейса:

  - ```ListGraph```, хранящий граф в виде массива списков смежности,
  - ```MatrixGraph```, хранящий граф в виде матрицы смежности,
  - ```SetGraph```, хранящий граф в виде массива хэш-таблиц/сбалансированных деревьев поиска,
  - ```ArcGraph```, хранящий граф в виде одного массива пар {from, to}.

Также необходимо реализовать конструктор, принимающий ```const IGraph&```. Такой конструктор должен скопировать переданный граф в создаваемый объект.
Для каждого класса создавайте отдельные h и cpp файлы.
Число вершин графа задается в конструкторе каждой реализации.

## Количество различных путей
Дан невзвешенный неориентированный граф. В графе может быть несколько кратчайших путей между какими-то вершинами. Найдите количество различных кратчайших путей между заданными вершинами. Требуемая сложность O(V+E). 

**Формат ввода**

*v*: кол-во вершин (макс. 50000),

*n*: кол-во ребер(макс. 200000),

*n* пар реберных вершин,

пара вершин *(u, w)* для запроса. 

**Формат вывода**

Количество кратчайших путей от *v* к *w*. 

**Пример**

| Ввод | Вывод |
|------|-------|
| 4    | 2     |
| 5    |       |
| 0 1  |       |
| 0 2  |       |
| 1 2  |       |
| 1 3  |       |
| 2 3  |       |
|      |       |
| 0 3  |       |

## Города

Требуется отыскать самый короткий маршрут между городами. Из города может выходить дорога, которая возвращается в этот же город.

Требуемое время работы *O((N + M)log N)*, где *N* – количество городов, *M* – известных дорог между ними.

*N ≤ 10000, M ≤ 250000*.

Длина каждой дороги ≤ 10000.

**Формат ввода**

Первая строка содержит число *N* – количество городов.

Вторая строка содержит число *M* - количество дорог.

Каждая следующая строка содержит описание дороги (откуда, куда, время в пути). Все указанные дороги двусторонние. Между любыми двумя городами может быть больше одной дороги.

Последняя строка содержит маршрут (откуда и куда нужно доехать).

**Формат вывода**

Вывести длину самого короткого маршрута.

**Пример**

| Ввод  | Вывод |
|-------|-------|
| 6     | 9     |
| 9     |       |
| 0 3 1 |       |
| 0 4 2 |       |
| 1 2 7 |       |
| 1 3 2 |       |
| 1 4 3 |       |
| 1 5 3 |       |
| 2 5 3 |       |
| 3 4 4 |       |
| 3 5 6 |       |
| 0 2   |       |

## Пятнашки неточные

Написать алгоритм для решения игры в “пятнашки”. Решением задачи является приведение к виду: [ 1 2 3 4 ] [ 5 6 7 8 ] [ 9 10 11 12] [ 13 14 15 0 ], где 0 задает пустую ячейку. Достаточно найти хотя бы какое-то решение. Число перемещений костяшек не обязано быть минимальным. 

**Формат ввода**

Начальная расстановка.

**Формат вывода**

Если вам удалось найти решение, то в первой строке файла выведите число перемещений, которое требуется сделать в вашем решении. А во второй строке выведите соответствующую последовательность ходов: L означает, что в результате перемещения костяшка сдвинулась влево, R – вправо, U – вверх, D – вниз. Если же выигрышная конфигурация недостижима, то выведите в выходной файл одно число −1. 

**Пример**

| Ввод                               | Вывод |
|------------------------------------|-------|
| 1 2 3 0 5 6 7 4 9 10 11 8 13 14 15 | 3     |


## Минимальное остовное дерево

Дан неориентированный связный граф. Требуется найти вес минимального остовного дерева в этом графе.
  - Вариант 1. Для построения минимального остовного дерева используйте алгоритм Крускала.
  - Вариант 2. Для построения минимального остовного дерева используйте алгоритм Прима.

**Формат ввода**

Первая строка содержит два натуральных числа *n* и *m* — количество вершин и ребер графа соответственно *(1 ≤ n ≤ 20000, 0 ≤ m ≤ 100000)*.
Следующие m строк содержат описание ребер по одному на строке.
Ребро номер *i* описывается тремя натуральными числами *b<sub>i</sub>*, *e<sub>i</sub>* и *w<sub>i</sub>* — номера концов ребра и его вес соответственно *(1 ≤ b<sub>i</sub>, e<sub>i</sub> ≤ n, 0 ≤ w<sub>i</sub> ≤ 100000)*.

**Формат вывода**

Выведите единственное целое число - вес минимального остовного дерева.


**Пример 1**

| Ввод  | Вывод |
|-------|-------|
| 4 4   | 7     |
| 1 2 1 |       |
| 2 3 2 |       |
| 3 4 5 |       |
| 4 1 4 |       |

